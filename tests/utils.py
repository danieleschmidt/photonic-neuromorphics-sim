"""Testing utilities and helper functions."""\n\nimport numpy as np\nimport torch\nimport json\nimport tempfile\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Union\nfrom unittest.mock import Mock, MagicMock\n\n\nclass TestDataGenerator:\n    \"\"\"Generate test data for photonic neuromorphics simulations.\"\"\"\n    \n    @staticmethod\n    def spike_train(\n        num_timesteps: int = 1000,\n        num_neurons: int = 784,\n        firing_rate: float = 0.1,\n        seed: Optional[int] = 42\n    ) -> np.ndarray:\n        \"\"\"Generate a Poisson spike train.\n        \n        Args:\n            num_timesteps: Number of time steps\n            num_neurons: Number of neurons\n            firing_rate: Average firing rate\n            seed: Random seed for reproducibility\n            \n        Returns:\n            Binary spike train array\n        \"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        return np.random.poisson(firing_rate, size=(num_timesteps, num_neurons))\n    \n    @staticmethod\n    def synaptic_weights(\n        input_size: int = 784,\n        output_size: int = 256,\n        weight_std: float = 0.1,\n        seed: Optional[int] = 42\n    ) -> torch.Tensor:\n        \"\"\"Generate synaptic weight matrix.\n        \n        Args:\n            input_size: Number of input neurons\n            output_size: Number of output neurons  \n            weight_std: Standard deviation of weights\n            seed: Random seed for reproducibility\n            \n        Returns:\n            Weight matrix tensor\n        \"\"\"\n        if seed is not None:\n            torch.manual_seed(seed)\n        return torch.randn(input_size, output_size) * weight_std\n    \n    @staticmethod\n    def optical_spectrum(\n        wavelength_range: tuple = (1500e-9, 1600e-9),\n        num_points: int = 1000,\n        noise_level: float = 0.01,\n        seed: Optional[int] = 42\n    ) -> Dict[str, np.ndarray]:\n        \"\"\"Generate optical spectrum data.\n        \n        Args:\n            wavelength_range: (min_wl, max_wl) in meters\n            num_points: Number of spectral points\n            noise_level: Noise level (0-1)\n            seed: Random seed\n            \n        Returns:\n            Dictionary with wavelength and transmission arrays\n        \"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        wavelengths = np.linspace(wavelength_range[0], wavelength_range[1], num_points)\n        center_wl = (wavelength_range[0] + wavelength_range[1]) / 2\n        width = (wavelength_range[1] - wavelength_range[0]) / 10\n        \n        # Gaussian transmission profile with noise\n        transmission = np.exp(-0.5 * ((wavelengths - center_wl) / width) ** 2)\n        transmission += np.random.normal(0, noise_level, num_points)\n        transmission = np.clip(transmission, 0, 1)\n        \n        return {\n            \"wavelength\": wavelengths,\n            \"transmission\": transmission\n        }\n    \n    @staticmethod\n    def device_parameters(\n        device_type: str = \"mzi\",\n        variation_percent: float = 5.0,\n        seed: Optional[int] = 42\n    ) -> Dict[str, float]:\n        \"\"\"Generate device parameters with process variation.\n        \n        Args:\n            device_type: Type of device (mzi, microring, etc.)\n            variation_percent: Process variation percentage\n            seed: Random seed\n            \n        Returns:\n            Dictionary of device parameters\n        \"\"\"\n        if seed is not None:\n            np.random.seed(seed)\n        \n        base_params = {\n            \"mzi\": {\n                \"length\": 100e-6,\n                \"phase_efficiency\": 10e-6,\n                \"insertion_loss\": 1.0,\n                \"extinction_ratio\": 20.0\n            },\n            \"microring\": {\n                \"radius\": 10e-6,\n                \"coupling_gap\": 200e-9,\n                \"quality_factor\": 10000,\n                \"fsr\": 10e-9\n            },\n            \"waveguide\": {\n                \"width\": 450e-9,\n                \"height\": 220e-9,\n                \"loss_db_cm\": 0.1,\n                \"bend_radius\": 5e-6\n            }\n        }\n        \n        if device_type not in base_params:\n            raise ValueError(f\"Unknown device type: {device_type}\")\n        \n        params = base_params[device_type].copy()\n        \n        # Add process variation\n        for key, value in params.items():\n            variation = np.random.normal(0, variation_percent / 100)\n            params[key] = value * (1 + variation)\n        \n        return params\n\n\nclass MockSimulator:\n    \"\"\"Mock simulator for testing without actual simulation.\"\"\"\n    \n    def __init__(self, config: Optional[Dict] = None):\n        self.config = config or {}\n        self.results = {}\n    \n    def run_optical_simulation(\n        self, \n        components: List[str],\n        parameters: Dict[str, Any]\n    ) -> Dict[str, np.ndarray]:\n        \"\"\"Mock optical simulation.\"\"\"\n        num_points = self.config.get(\"num_points\", 1000)\n        \n        # Generate realistic-looking results\n        wavelengths = np.linspace(1500e-9, 1600e-9, num_points)\n        transmission = np.random.rand(num_points) * 0.8 + 0.1\n        phase = np.random.rand(num_points) * 2 * np.pi\n        \n        return {\n            \"wavelength\": wavelengths,\n            \"transmission\": transmission,\n            \"phase\": phase\n        }\n    \n    def run_spice_simulation(\n        self,\n        netlist: str,\n        analysis: str = \"tran\"\n    ) -> Dict[str, np.ndarray]:\n        \"\"\"Mock SPICE simulation.\"\"\"\n        duration = self.config.get(\"duration\", 1e-6)\n        timestep = self.config.get(\"timestep\", 1e-12)\n        \n        time_points = np.arange(0, duration, timestep)\n        voltage = np.sin(2 * np.pi * 1e6 * time_points) * 3.3\n        current = np.cos(2 * np.pi * 1e6 * time_points) * 1e-3\n        \n        return {\n            \"time\": time_points,\n            \"voltage\": voltage,\n            \"current\": current\n        }\n\n\nclass TestFileManager:\n    \"\"\"Manage test files and temporary directories.\"\"\"\n    \n    def __init__(self, base_dir: Optional[Path] = None):\n        self.base_dir = base_dir or Path(tempfile.mkdtemp())\n        self.created_files = []\n        self.created_dirs = []\n    \n    def create_test_file(\n        self,\n        filename: str,\n        content: Union[str, bytes, Dict],\n        subdir: Optional[str] = None\n    ) -> Path:\n        \"\"\"Create a test file with specified content.\"\"\"\n        if subdir:\n            file_dir = self.base_dir / subdir\n            file_dir.mkdir(parents=True, exist_ok=True)\n        else:\n            file_dir = self.base_dir\n        \n        file_path = file_dir / filename\n        \n        if isinstance(content, dict):\n            # JSON content\n            with open(file_path, 'w') as f:\n                json.dump(content, f, indent=2)\n        elif isinstance(content, bytes):\n            # Binary content\n            with open(file_path, 'wb') as f:\n                f.write(content)\n        else:\n            # Text content\n            with open(file_path, 'w') as f:\n                f.write(str(content))\n        \n        self.created_files.append(file_path)\n        return file_path\n    \n    def create_gds_file(self, filename: str = \"test.gds\") -> Path:\n        \"\"\"Create a mock GDS file.\"\"\"\n        # Simple GDS header (not a valid GDS, just for testing)\n        gds_header = b'\\x00\\x06\\x00\\x02\\x00\\x01'\n        return self.create_test_file(filename, gds_header)\n    \n    def create_spice_netlist(\n        self,\n        filename: str = \"test.sp\",\n        title: str = \"Test Circuit\"\n    ) -> Path:\n        \"\"\"Create a SPICE netlist file.\"\"\"\n        netlist = f\"\"\"\n* {title}\n.title {title}\n\n* Voltage sources\nVdd vdd 0 DC 3.3V\nVss vss 0 DC 0V\n\n* Test circuit\nR1 vdd out 1k\nC1 out 0 1p\n\n.tran 1p 1n\n.end\n\"\"\"\n        return self.create_test_file(filename, netlist)\n    \n    def create_verilog_module(\n        self,\n        filename: str = \"test.v\",\n        module_name: str = \"test_module\"\n    ) -> Path:\n        \"\"\"Create a Verilog module file.\"\"\"\n        verilog = f\"\"\"\n// Test Verilog module\nmodule {module_name} (\n    input wire clk,\n    input wire rst_n,\n    input wire [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 8'h00;\n        end else begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule\n\"\"\"\n        return self.create_test_file(filename, verilog)\n    \n    def cleanup(self):\n        \"\"\"Clean up created files and directories.\"\"\"\n        import shutil\n        \n        for file_path in self.created_files:\n            if file_path.exists():\n                file_path.unlink()\n        \n        # Remove empty directories\n        try:\n            if self.base_dir.exists():\n                shutil.rmtree(self.base_dir)\n        except OSError:\n            pass\n\n\nclass PerformanceTracker:\n    \"\"\"Track performance metrics during tests.\"\"\"\n    \n    def __init__(self):\n        self.metrics = {}\n        self.start_times = {}\n    \n    def start_timer(self, metric_name: str):\n        \"\"\"Start timing a metric.\"\"\"\n        import time\n        self.start_times[metric_name] = time.perf_counter()\n    \n    def stop_timer(self, metric_name: str) -> float:\n        \"\"\"Stop timing a metric and return elapsed time.\"\"\"\n        import time\n        if metric_name not in self.start_times:\n            raise ValueError(f\"Timer {metric_name} was not started\")\n        \n        elapsed = time.perf_counter() - self.start_times[metric_name]\n        self.metrics[metric_name] = elapsed\n        del self.start_times[metric_name]\n        return elapsed\n    \n    def add_metric(self, metric_name: str, value: float):\n        \"\"\"Add a metric value.\"\"\"\n        self.metrics[metric_name] = value\n    \n    def get_metrics(self) -> Dict[str, float]:\n        \"\"\"Get all collected metrics.\"\"\"\n        return self.metrics.copy()\n    \n    def save_metrics(self, filepath: Path):\n        \"\"\"Save metrics to JSON file.\"\"\"\n        with open(filepath, 'w') as f:\n            json.dump(self.metrics, f, indent=2)\n\n\ndef assert_arrays_close(\n    actual: np.ndarray,\n    expected: np.ndarray,\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n    msg: str = \"\"\n):\n    \"\"\"Assert that two arrays are element-wise close.\"\"\"\n    try:\n        np.testing.assert_allclose(actual, expected, rtol=rtol, atol=atol)\n    except AssertionError as e:\n        error_msg = f\"Arrays not close enough: {msg}\\n{str(e)}\"\n        raise AssertionError(error_msg)\n\n\ndef assert_valid_gds(filepath: Path):\n    \"\"\"Assert that a file is a valid GDS file (basic check).\"\"\"\n    assert filepath.exists(), f\"GDS file does not exist: {filepath}\"\n    assert filepath.suffix.lower() == '.gds', f\"File is not a GDS file: {filepath}\"\n    \n    # Basic file size check\n    assert filepath.stat().st_size > 0, f\"GDS file is empty: {filepath}\"\n\n\ndef assert_valid_spice(filepath: Path):\n    \"\"\"Assert that a file is a valid SPICE netlist (basic check).\"\"\"\n    assert filepath.exists(), f\"SPICE file does not exist: {filepath}\"\n    assert filepath.suffix.lower() in ['.sp', '.cir', '.net'], f\"File is not a SPICE file: {filepath}\"\n    \n    with open(filepath, 'r') as f:\n        content = f.read()\n        \n    # Basic SPICE syntax checks\n    assert '.end' in content.lower(), \"SPICE file missing .end statement\"\n    assert len(content.strip()) > 0, \"SPICE file is empty\"\n\n\ndef assert_valid_verilog(filepath: Path):\n    \"\"\"Assert that a file is a valid Verilog file (basic check).\"\"\"\n    assert filepath.exists(), f\"Verilog file does not exist: {filepath}\"\n    assert filepath.suffix.lower() in ['.v', '.sv'], f\"File is not a Verilog file: {filepath}\"\n    \n    with open(filepath, 'r') as f:\n        content = f.read()\n    \n    # Basic Verilog syntax checks\n    assert 'module' in content, \"Verilog file missing module declaration\"\n    assert 'endmodule' in content, \"Verilog file missing endmodule statement\"\n    assert len(content.strip()) > 0, \"Verilog file is empty\"\n\n\ndef skip_if_no_gpu():\n    \"\"\"Skip test if no GPU is available.\"\"\"\n    import pytest\n    try:\n        import torch\n        if not torch.cuda.is_available():\n            pytest.skip(\"GPU not available\")\n    except ImportError:\n        pytest.skip(\"PyTorch not available\")\n\n\ndef skip_if_no_spice():\n    \"\"\"Skip test if SPICE simulator is not available.\"\"\"\n    import pytest\n    import shutil\n    \n    if shutil.which('ngspice') is None:\n        pytest.skip(\"SPICE simulator not available\")\n\n\ndef parametrize_devices():\n    \"\"\"Decorator to parametrize tests across different device types.\"\"\"\n    import pytest\n    \n    device_types = [\"mzi\", \"microring\", \"waveguide\", \"detector\"]\n    return pytest.mark.parametrize(\"device_type\", device_types)\n\n\ndef parametrize_wavelengths():\n    \"\"\"Decorator to parametrize tests across different wavelengths.\"\"\"\n    import pytest\n    \n    wavelengths = [1310e-9, 1490e-9, 1550e-9, 1625e-9]  # Common telecom wavelengths\n    return pytest.mark.parametrize(\"wavelength\", wavelengths)